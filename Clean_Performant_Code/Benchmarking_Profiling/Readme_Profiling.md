# Profiling

[Zurück](../Performance_Optimization/Readme_Performance_Optimization.md)

---

## Inhalt

  * [Allgemeines](#link1)
  * [Visual Studio Diagnostic Tools](#link2)

---

#### Quellcode

[*Advent_of_Code_2024_No_10.cpp*](Advent_of_Code_2024_No_10.cpp)<br />
[*Advent_of_Code_2024_No_11.cpp*](Advent_of_Code_2024_No_11.cpp)<br />

---

## Allgemeines <a name="link1"></a>

Aus dem Buch &bdquo;[*Professional C++*](https://www.amazon.de/Professional-C-Marc-Gregoire/dp/1394193173)&rdquo; von Marc Gregoire zitiert:

&bdquo;Es ist ratsam, beim Entwerfen und Programmieren an die Effizienz zu denken.
Es macht keinen Sinn, offensichtlich ineffiziente Programme zu schreiben, wenn dies mit gesundem Menschenverstand oder erfahrungsbasierter Intuition vermieden werden kann.

Ich rate Ihnen jedoch dringend, sich in der Design- und Programmierphase nicht zu sehr auf die Leistung zu konzentrieren.

Es empfiehlt sich, zunächst ein sauberes, gut strukturiertes Design und eine gut strukturierte Implementierung zu erstellen, dann einen Profiler zu verwenden und nur die Teile zu optimieren, die vom Profiler als Leistungsengpässe gekennzeichnet werden.

Denken Sie an die in dem Buch
&bdquo;[*Computer Architecture: A Quantitative Approach*](https://www.amazon.de/Computer-Architecture-Quantitative-Approach-Kaufmann)&rdquo;
von John L. Hennessy, David A. Patterson, Christos Kozyrakis
eingeführte &bdquo;90/10&rdquo;-Regel, die besagt, dass 90 Prozent der Laufzeit der meisten Programme
auf nur 10 Prozent des Codes entfallen.

Das bedeutet, dass Sie 90 Prozent Ihres Codes optimieren könnten, die Laufzeit des Programms aber dennoch nur um 10 Prozent verbessern würden.

Natürlich möchten Sie die am häufigsten beanspruchten Codeteile für die spezifische Arbeitslast optimieren, die das Programm voraussichtlich ausführen wird.&rdquo;

Und weiter:

&bdquo;Daher ist es oft hilfreich, ein Programm zu &bdquo;*profilen*&rdquo;, um festzustellen, welche Codeteile optimiert werden müssen.

Es gibt viele Profiling-Tools, die Programme während der Ausführung analysieren und Daten zur Leistung generieren.

Die meisten Profiling-Tools ermöglichen Analysen auf Funktionsebene, indem sie die für jede Funktion im Programm benötigte Zeit (oder den Prozentsatz der gesamten Ausführungszeit) angeben.

Nachdem Sie ein Profiling für Ihr Programm ausgeführt haben, können Sie in der Regel sofort erkennen, welche Programmteile optimiert werden müssen.

Profiling vor und nach der Optimierung ist unerlässlich, um den Erfolg Ihrer Optimierungen nachzuweisen.&rdquo;

---

## Visual Studio Diagnostic Tools <a name="link2"></a>

Abhängig von Ihrer Version von VC++ stehen Ihnen verschiedene Analysetools zur Verfügung.
Wir geben in den folgenden drei Abbildungen einen Überblick über deren Funktionalität:

In *Abbildung* 1 finden Sie eine Darstellung des *Hot Path*:

<img src="Profiling_01.png" width="500">

*Abbildung* 1: Darstellung des *Hot Path*.


Diese Drilldown-Ansicht zeigt oben den Hot Path,
in einem weiteren Fenster (*Abbildung* 2) den eigentlichen Code der Memberfunktion:

<img src="Profiling_02.png" width="800">

*Abbildung* 2: Der *Call-Tree* mit Ausführungszeiten: *Total CPU* und *Self CPU*.

Die Codeansicht in *Abbildung* 3 zeigt den prozentualen Anteil der Ausführungszeit, den eine Codezeile benötigt.

Die rechenintensivsten Zeilen werden rot dargestellt. Diese Ansicht macht deutlich, dass das
Einlesen des linken Teils (`leftpart`) in etwa halb so lange dauert
wie das des rechten Teils (`rightPart`).

<img src="Profiling_03.png" width="500">

*Abbildung* 3: Quelltext mit Hervorhebung der rechenintensivsten Zeilen.

---

[Zurück](../Performance_Optimization/Readme_Performance_Optimization.md)

---
